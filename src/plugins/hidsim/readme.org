* hidsim
This plugin provides functionality to inject events of human interface devices (HID) into the Xen guest under investigation by utilizing the [[https://wiki.qemu.org/Documentation/QMP][QEMU machine protocol (QMP)]].
It can either replay pre-recorded and normalized HID-events -- evdev-events to be more specific --, which were gathered by the tool [[file:../../helpers/hiddump/][src/helpers/hiddump]] or simulate random mouse movements.

If the latter approach is chosen and the Xen guest is a Windows 7-system, it is possible to listen on GUI updates and look for buttons, which are then clicked automatically.

** Usage
To run the plugin and inject random mouse movements, use ~-a hidsim~ with no further options.
If you want to see verbose output, to follow along, use the ~-v~-flag of course.

#+BEGIN_SRC
sudo ./src/drakvuf -r <ISF-file.json> -d <domID> -a hidsim -v
#+END_SRC

If you are observing a Windows 7 system, you can specify ~--hid-monitor-gui~ and supply a win32k-IST-file via ~-W~ like this:

#+begin_src
sudo ./src/drakvuf -r <ISF-file.json> -W <Win32K-ISF-file.json> -d <domID> -a hidsim --hid-monitor-gui
#+end_src

The following screencast illustrates the clicking behaviour:
#+html: <p align="center"><img width="600" src="res/btn_demo.gif"></p>

/Note: This feature has been tested on Win 7 SP1 32-bit, if you have troubles on patches Win 7 version try to disable atom parsing by recompiling after running ~./configure --disable-atoms~. For information on the creation of the referenced intermediate symbol table-files, see the section "Excursus: Derivation of IST-files" below./

To inject pre-recorded evdev-events specified in a template-file, use the option ~--hid-template~ and specify the path to the template-file to use like so:

#+BEGIN_SRC
sudo ./src/drakvuf -r <ISF-file.json> -d <domID> -a hidsim -v --hid-template ../hid-template.bin
#+END_SRC

The following screencast illustrates the injection of HID-events from a template file, which was prerecorded with [[../../helpers/hiddump/][hiddump]]:
#+html: <p align="center"><img width="600" src="res/template_demo.gif"></p>

Note, that this file has to be generated by ~./src/hiddump~. See [[../../helpers/hiddump/readme.org][../../helpers/hiddump/readme.org]] for more infos on its working, the resulting file format and a description of the usage of this tool.

** Dependencies
The ~hidsim~-plugin uses pthreads and json-c. Both libaries are hooked into the automake-system.

** Background
*** HID event injection
As already stated in the first paragraph, the injection of HID-events is accomplished by the utilization of Qemu's machine protocol. QMP is a protocol for applications to talk with QEMU and operate a Qemu instance by sending JSON-commands (according to RFC 4627) to its Unix domain socket, which are specified by the QAPI.
~hidsim~ primarily utilizes QMP's command ~send-input-event~ to simulate user input by sending mouse movement and keyboard events.

**** Exemplary QMP usage to illustrate the inner working
Xen creates Unix domain sockets serving as QMP-endpoints under ~/run/xen/qmp-libxl-<domID>~.

Alternatively you could specify, a specific socket by adding to the configuration file of the Xen guest:
#+BEGIN_SRC shell
cat << EOF >> /etc/xen/<machine.cfg>
heredoc> # Specify QMP Socket
device_model_args = [
    "-chardev",
    "socket,id=win7-sock-qmp,path=/run/xen/win7-sock-qmp,server,nowait",
    "-mon",
    "chardev=win7-sock-qmp,mode=control"
]
EOF
#+END_SRC

To manually test QMP, one can connect to the Unix domain socket with ~netcat~ or ~telnet~:

#+BEGIN_SRC shell
# Open connection to Unix domain socket for QMP connection
sudo nc -U /run/xen/qmp-libxl-1

# Negotiate QMP capabilities
{ "execute": "qmp_capabilities" }

# Utilize input-send-event to move the mouse cursor
{
   "execute":"input-send-event",
   "arguments":{
      "events":[
	 {
	    "type":"abs",
	    "data":{
	       "axis":"x",
	       "value":32000
	    }
	 },
	 {
	    "type":"abs",
	    "data":{
	       "axis":"y",
	       "value":31000
	    }
	 }
      ]
   }
}
# Send ctrl-alt-delete
{
   "execute":"input-send-event",
   "arguments":{
      "events":[
	 {
	    "type":"key",
	    "data":{
	       "down":true,
	       "key":{
		  "type":"qcode",
		  "data":"ctrl"
	       }
	    }
	 },
	 {
	    "type":"key",
	    "data":{
	       "down":true,
	       "key":{
		  "type":"qcode",
		  "data":"alt"
	       }
	    }
	 },
	 {
	    "type":"key",
	    "data":{
	       "down":true,
	       "key":{
		  "type":"qcode",
		  "data":"delete"
	       }
	    }
	 }
      ]
   }
}
#+END_SRC

*** GUI reconstruction
This section describes the approach to monitor the system for GUI updates, in order to be able to find clickable buttons and click them eventually.

**** Background on the working of the GUI reconstruction
The Windows GUI subsystem is structured by the concepts of sessions, window stations, desktops and windows. A session is the logon-environment of a user. Each session has multiple window stations -- interactive ones for handling user input and non-interactive ones for services. Each window station has a so-called atom table, which is basically a hashtable of strings and a notable attribute in the context of GUI forensics. The atom entries are shared by processes and -- among other things -- are used to track classes of GUI objects.
Most important is, that each window station contains a list of associated desktops. Those house all GUI objects, such as windows, buttons, menus and the like, as the name implies [1].

To perform a reconstruction of the GUI presented to the user, the interactive window stations and all of their non-empty desktops have to be found. One of approach of finding all windows stations is to look at each thread of each process and determine, if it is a GUI-thread. Windows holds its processes in a doubly-link list of ~_EPROCESS~-structs, which contain a so-called ~ActiveProcessList~-field. The kernel symbol ~PsActiveProcessHead~ points to the head of this list of active processes. Each process has one or more threads. If the thread environment block contains a pointer to a ~Win32Threadinfo~-struct (and an ~tagDESKTOPINFO~-struct) it is GUI-thread. If this is the case, the housing window station can be retrieved by looking at the ~Win32Threadinfo~-struct more closely, which contains a field named ~pwinsta~ -- a pointer to the window station. The address to the windowstation can then be collected in a set. Afterwards all windows stations can be traversed and all desktops with all of their windows can be retrieved [2]. In this way the ~WinSta0\Default~-desktop, presented to the first user, who logged on locally, can be reconstructed. For a detailed description of the procedure implemented in the ~hidsim~-plugin refer to the following section.

**** Overall procedure for automatically clicking buttons
***** Trap GUI updates
To reconstruct the GUI only if a GUI update occurred, a trap is placed on the systemcall ~NtUserShowWindow(...)~ provided by ~win32k.sys~. To find the address of this systemcall the following steps are taken:
1. Find the RVA of the function of interest (here ~NtUserShowWindow~) from the win32k-IST-JSON, which has to be provided via the command line
2. Find the RVA of the GUI service table called ~W32pServiceTable~ (also known as the /GUI SSDT/) from the a/m win32k-IST-JSON
3. Find the VA of ~KeServiceDescriptorTableShadow~-symbol
4. Retrieve the directory table base (DTB) of an arbitrary interactive process by reading the CR3-register
5. Use the DTB to resolve the pointer to the GUI SSDT
6. Find the address to trap, by subtracting the RVA of ~W32pServiceTable~ from the VA of the GUI SSDT and then adding the function offset of ~NtUserShowWindow(...)~

After receiving a GUI update, the following procedure is applied to reconstruct the GUI windows after a short delay. The default desktop is retrieved once by performing the following steps:

***** Retrieval of window stations
At first a list of Window Station has to be retrieved. To do this the linked list of ~_EPROCESS~-structs is traversed to perform the following steps for each process:
1. Find the ~ThreadListHead~
2. Traverse the linked list of ~_ETHREAD~-structs and check, if the current ~_ETHREAD~ is a GUI thread
   This is done by using the ~TEB~-struct in ~_KTHREAD~, which houses a ~Win32ThreadInfo~-struct:
   1. If current ~_ETHREAD~ is a GUI-thread, retrieve pointer ~pwinsta~ to the housing winsta of type ~tagWINDOWSTATION~-struct
   2. If current ~_ETHREAD~ is not a GUI-thread, continue

***** Parsing of window stations
To parse each ~tagWINDOWSTATION~-struct, do the following
1. Retrieve the session ID
2. Retrieve the offset to ~_RTL_ATOM_TABLE~ and parse it (not detailed here)
3. Retrieve the flags (specifying, if interactive or not)
4. Traverse all ~tagDESKTOP~-structs associated with the winsta
   1. Find the ~rpdesklist~-pointer to the head of the linked list of associated desktops (of type ~tagDESKTOP~)
   2. Traverse the linked list of desktops by using their ~rpnext~-pointers

***** Finding a button of interest
As stated above the default desktop will be retrieved once, on every subsequent GUI update, a current list of windows associated with this desktop will be constructed as follows:
****** Retrieval of windows
1. Find the root window
   1. Find ~_DESKTOPINFO~
   2. Find the ~spwnd~-member, which is a pointer to the first ~tagWND~-struct
2. Allocate an empty list of windows
3. Form a list of top windows by following the ~pNextWindow~-member of the ~tagWND~-struct until it is ~NULL~ or it was already seen before
   1. Check the visibility of each window (this is the case, if the ~WS_VISIBLE~-flag is set)
      - If it is not visible, continue
      - If it is visible, add it to list of visible windows
4. Traverse the list of visbile windows in their reverse order
   - For each window in the list, get the child window and recurse to the previous step

After performing this last step, the depth-ordered list of the addresses to all visible ~tagWND~-structs of a desktop is available.

****** Identifying buttons to click
This list of windows will be traversed in reverse. The top /n/ ~tagWND~-struct are considered. Four simple heuristics are employed to determine, if a ~tagWND~-struct, which can be a button as well, should be clicked:
    - its class ID is not part of definitely irrelevant window classes
    - its size is <= ~BUTTON_RATION~ -- a factor determined by looking at the root pane of the desktop
    - its text contains a string of interest within the first few character (both parameters are specified in [[file:src/drakvuf/src/plugins/hidsim/gui/vmi_win_gui_filter_definitions.h][vmi_win_gui_filter_definitions.h]])
    - its area is actual visible on screen
If a ~tagWND~-struct is present, which fulfills all four requirements, the center of the clickable area is handed over to the injection thread, which will construct and send a QMP-comamnd to click on it.
Note, that this behaviour is activated only, when ~--hid-monitor-gui~ is specified.

***** Excursus: Derivation of IST-files in JSON-Format from PDB-files
In order to determine the struct offsets, an intermediate symbol file has to be supplied, which assigns symbol names to memory offsets. To generate such an IST-file, you need to know the GUID and the age of the kernel-module in question -- here ~win32k.sys~. Those uniquely identify a particular version of a PDB-file. You can retrieve those two values, by utilizing a utility called [[https://github.com/CERT-Polska/drakvuf-sandbox/blob/master/drakrun/drakrun/drakpdb.py][drakpdb.py]], which is part of CERT.pl's GUI-frontend to Drakvuf:

#+begin_src shell
# Get drakpdb.py
wget https://raw.githubusercontent.com/CERT-Polska/drakvuf-sandbox/master/drakrun/drakrun/drakpdb.py

# Install dependencies via pip
pip3 install pdbparse tqdm

# Get the GUID and age from the file in question
python3 drakpdb.py pdb_guid --file ~/share/win32k.sys
#+end_src

Since the GUID is now known, an IST-file can be generated by retrieving the PDB-file matching the given GUID from Microsoft's symbol servers and converting it to the JSON-format, which is used by Volatility:
#+begin_src shell
# Get the code and install it via pip
git clone https://github.com/volatilityfoundation/volatility3.git
cd volatility3; pip3 install .

# Run pdbconv.py to generate the JSON representation of the pdb-file in question
python3 ./volatility3/framework/symbols/windows/pdbconv.py \
         --guid 6a1a499eed2d42d29e40866f0c374d492 \
         -p win32k.pdb -o windows7-sp1-win32k.json
#+end_src

** Footnotes
[1] Cf. Ligh, M. H., Case, A., Levy, J., & Walters, A. (2014). The art of memory forensics. John Wiley & Sons. p. 408 f.

[2] This information is based Brendan Dolan-Gavitt's work on GDI utilities.  https://www.cc.gatech.edu/~brendan/volatility/
